# 对称二叉树

> 给定一个二叉树，检查它是否是镜像对称的。  
> 例如，二叉树  [1,2,2,3,4,4,3] 是对称的。 \*

- ⁠ 1
- ⁠ / \
- ⁠ 2 2
- ⁠/ \ / \
- 3 4 4 3
-
-
- 但是下面这个  [1,2,2,null,3,null,3] 则不是镜像对称的:
-
- ⁠ 1
- ⁠ / \
- ⁠ 2 2
- ⁠ \ \
- ⁠ 3 3
-
-

> 说明:  
> TreeNode 对象 root 的结构

```javascript
function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}
```

## 解法一

> 使用递归进行 DFS 深度优先遍历，邮箱遍历一个分支到最底部，复杂度为 O(n)，最坏的情况遍历一整棵树，同时满足一棵树的两个节点都对称时候则表示对称

```javascript
var isSymmetric = function(root) {
  if (!root) {
    return true;
  }

  let recursivedDFS = (left, right) => {
    // 兩个节点都為空直接相同返回true
    if (!left && !right) {
      return true;
    }

    // 都有值的话进行下一步比对
    if (left && right) {
      if (left.val != right.val) {
        return false;
      }
      return (
        recursivedDFS(left.left, right.right) &&
        recursivedDFS(left.right, right.left)
      );
    }

    // 一个为空，一个不为空，则不相等，返回false
    return false;
  };

  return recursivedDFS(root.left, root.right);
};
```

## 解法二

> 使用 BFS 广度优先遍历，也就是一层一层的遍历，然后将左右节点成对的放入队列中，通过队列有序的一层一层的遍历，如果其中值不相同或者出现一边为空的情况则表示不是对称的树，复杂度也是 O(n)

```javascript
var isSymmetric = function(root) {
  if (!root) {
    return true;
  }

  let recursivedBFS = (leftNode, rightNode) => {
    let queue = [leftNode, rightNode];

    while (queue.length != 0) {
      // 因为节点是从左到右的队列依次放入对称的两个节点
      // 所以两次shift依次反悔的是用来比较的两个节点
      let left = queue.shift();
      let right = queue.shift();

      if (left.val != right.val) {
        return false;
      }

      if (left.left) {
        if (!right.right) return false;
        // 两节点都不为空才会放入队列
        queue.push(left.left);
        queue.push(right.right);
      } else if (right.right) {
        return false;
      }

      if (left.right) {
        if (!right.left) return false;
        queue.push(left.right);
        queue.push(right.left);
      } else if (right.left) {
        return false;
      }
    }
    return true;
  };

  if (root.left && root.right) {
    return recursivedBFS(root.left, root.right);
  }
  if (!root.left && !root.right) {
    return true;
  }

  return false;
};
```
