# 两数之和

> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。  
> 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素  
> 给定 nums = [2, 7, 11, 15], target = 9  
> 因为 nums[0] + nums[1] = 2 + 7 = 9  
> 所以返回 [0, 1]

## 解法一

> 这里 Map 也可以使用对象代替，主要用来记录已经访问过的元素，然后使用 target 减去后续元素的差值，在 Map 寻找是否存在这个差值，在的话则成立，直接返回  
> 这里的复杂度为 `O(n)`，利用 `Map` 的特性只进行一次一次遍历，也可以使用对象的属性记录，然后使用`hasOwnProperty`判断是否存在

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
  let temp = new Map();

  for (let i = 0, j = nums.length; i < j; i++) {
    let other = target - nums[i];
    // Map中存在差值的话，则表明条件成立
    if (temp.has(other)) {
      // 直接返回Map中的对应value，即另一个数的下标，与当前下标一起返回
      return [temp.get(other), i];
    }
    temp.set(nums[i], i);
  }
};
```

## 解法二

> 这里需要嵌套遍历，所以复杂度为 O(n^2)，这里从第一个元素开始，然后在第一个元素以后到最后这个范围查找是否存在满足条件的值，这个比较容易理解，但是复杂度较高。

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
  let tempArray = [];
  let length = nums.length;

  for (var i = 0; i < length - 1; i++) {
    for (var j = i + 1; j < length; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j];
      }
    }
  }
};
```
